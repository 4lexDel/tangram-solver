{"version":3,"file":"static/js/811.1de8cb0d.chunk.js","mappings":"mBAAO,MAAMA,EACXC,YAAAA,CAAaC,GAKX,OAJA,SAASC,EAAWC,GAClB,OAAOC,MAAMC,QAAQF,GAASA,EAAMG,IAAIJ,GAAcC,CACxD,CAEOD,CAAWD,EACpB,CAEAM,cAAAA,CAAeC,EAAMC,GACnB,GAAID,EAAKE,SAAWD,EAAKC,OACvB,OAAO,EAGT,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAKE,OAAQC,IAAK,CACpC,GAAIH,EAAKG,GAAGD,SAAWD,EAAKE,GAAGD,OAC7B,OAAO,EAGT,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAKG,GAAGD,OAAQE,IAClC,GAAIJ,EAAKG,GAAGC,KAAOH,EAAKE,GAAGC,GACzB,OAAO,CAGb,CAEA,OAAO,CACT,CAEAC,aAAAA,CAAcC,GACZ,MAAMC,EAAOD,EAAOJ,OACdM,EAAOF,EAAO,GAAGJ,OAGjBO,EAAmB,GACzB,IAAK,IAAIL,EAAI,EAAGA,EAAII,EAAMJ,IAAK,CAC7B,MAAMM,EAAS,GACf,IAAK,IAAIP,EAAI,EAAGA,EAAII,EAAMJ,IACxBO,EAAOC,KAAKL,EAAOH,GAAGC,IAExBK,EAAiBE,KAAKD,EACxB,CAGA,MAAME,EAAgB,GACtB,IAAK,IAAIT,EAAI,EAAGA,EAAIK,EAAML,IAAK,CAC7B,MAAMU,EAAcJ,EAAiBN,GAAGW,UACxCF,EAAcD,KAAKE,EACrB,CAEA,OAAOD,CACT,CAEAG,cAAAA,CAAeT,GACb,MAAMU,EAAUV,EAAOJ,OACjBe,EAAUX,EAAO,GAAGJ,OAEpBgB,EAAiB,GAEvB,IAAK,IAAIf,EAAI,EAAGA,EAAIa,EAASb,IAAK,CAChC,MAAMU,EAAc,GACpB,IAAK,IAAIT,EAAIa,EAAU,EAAGb,GAAK,EAAGA,IAChCS,EAAYF,KAAKL,EAAOH,GAAGC,IAE7Bc,EAAeP,KAAKE,EACtB,CAEA,OAAOK,CACT,CAEAC,UAAAA,CAAWb,GACT,IAAIc,EAAOd,EAAO,GAAGJ,OACjBmB,EAAO,EACPC,EAAOhB,EAAOJ,OACdqB,EAAO,EAGX,IAAK,IAAIpB,EAAI,EAAGA,EAAIG,EAAOJ,OAAQC,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIE,EAAOH,GAAGD,OAAQE,KACf,IAAjBE,EAAOH,GAAGC,KACZgB,EAAOI,KAAKC,IAAIL,EAAMhB,GACtBiB,EAAOG,KAAKE,IAAIL,EAAMjB,GACtBkB,EAAOE,KAAKC,IAAIH,EAAMnB,GACtBoB,EAAOC,KAAKE,IAAIH,EAAMpB,IAM5B,IAAIwB,EAAgB,GACpB,IAAK,IAAIxB,EAAImB,EAAMnB,GAAKoB,EAAMpB,IAAK,CACjC,IAAIyB,EAAM,GACV,IAAK,IAAIxB,EAAIgB,EAAMhB,GAAKiB,EAAMjB,IAC5BwB,EAAIjB,KAAKL,EAAOH,GAAGC,IAErBuB,EAAchB,KAAKiB,EACrB,CACA,OAAOD,CACT,EChGK,MAAME,EACTC,WAAAA,CAAYC,GACRC,KAAKC,cAAgB,IAAI1C,EAEzByC,KAAKE,eAAiBH,EAEtBC,KAAKG,YAAc,CACvB,CAEAC,wBAAAA,CAAyBC,GACrB,IAAIC,EAAYD,EAAavC,KAAKyC,GAAUP,KAAKC,cAAcd,WAAWoB,EAAY,QAEtFC,QAAQC,IAAIH,GAEZ,IAAII,EAAiB,GAoBrB,OAlBAJ,EAAUK,SAAQJ,IACd,IAAIK,EAAoB,GAExBA,EAAkBjC,KAAK4B,GACvBK,EAAkBjC,KAAKqB,KAAKC,cAAclB,eAAewB,IAGzD,IAAIM,EAAeb,KAAKC,cAAczC,aAAa+C,GAEnD,IAAK,IAAIpC,EAAI,EAAGA,EAAI,EAAGA,IACnB0C,EAAeb,KAAKC,cAAc5B,cAAcwC,GAChDD,EAAkBjC,KAAKkC,GACvBD,EAAkBjC,KAAKqB,KAAKC,cAAclB,eAAe8B,IAG7DH,EAAe/B,KAAKqB,KAAKc,sBAAsBF,GAAmB,IAG/DF,CACX,CAEAI,qBAAAA,CAAsBC,GAClB,MAAMC,EAAe,GAErB,IAAK,MAAMrD,KAASoD,EAAQ,CACxB,IAAIE,GAAc,EAClB,IAAK,MAAMC,KAAeF,EACtB,GAAIhB,KAAKC,cAAclC,eAAeJ,EAAOuD,GAAc,CACvDD,GAAc,EACd,KACJ,CAECA,GACDD,EAAarC,KAAKhB,EAE1B,CAEA,OAAOqD,CACX,CAEAG,YAAAA,CAAapB,GAGT,IAAK,IAAIqB,EAAI,EAAGA,EAAIrB,EAAQ7B,OAAQkD,IAChC,IAAK,IAAIC,EAAI,EAAGA,EAAItB,EAAQ,GAAG7B,OAAQmD,KACd,GAAlBtB,EAAQqB,GAAGC,KAAUtB,EAAQqB,GAAGC,GAAK,EAGpD,CAEAC,KAAAA,CAAMhB,GAAyC,IAA9BP,EAAOwB,UAAArD,OAAA,QAAAsD,IAAAD,UAAA,GAAAA,UAAA,GAAC,KAAME,EAAQF,UAAArD,OAAA,QAAAsD,IAAAD,UAAA,GAAAA,UAAA,GAAC,KACpCvB,KAAKG,YAAc,EAGnB,IAAIuB,EAAY1B,KAAKI,yBAAyBE,GAU9C,OATAoB,EAAYA,EAAUC,MAAK,IAAOnC,KAAKoC,SAAW,GAAM,GAAK,IAIzD7B,EACCC,KAAKmB,aAAapB,GADVA,EAAUC,KAAKC,cAAczC,aAAawC,KAAKE,gBAG5DH,EAAUC,KAAK6B,QAAQ9B,EAAS2B,EAAW,EAAGD,GAEvC1B,CACX,CAEA8B,OAAAA,CAAQ9B,EAASO,EAAWwB,EAAOL,GAW/B,GAVAzB,KAAKG,cAEFsB,IACwB,GAApBnB,EAAUpC,OACT6D,YAAW,KACPN,EAAS1B,EAAQ,GAClB,KAECC,KAAKG,YAAc,KAAO,GAAGsB,EAAS1B,IAE1B,GAApBO,EAAUpC,OAAa,OAAO6B,EAElC,MAAMiC,EAAuB1B,EAAU,GAEvC,IAAK,IAAIlC,EAAI,EAAGA,EAAI4D,EAAqB9D,OAAQE,IAAK,CAClD,MAAMmC,EAAQyB,EAAqB5D,GAEnC,IAAK,IAAIgD,EAAI,EAAGA,EAAIrB,EAAQ7B,OAAQkD,IAChC,IAAK,IAAIC,EAAI,EAAGA,EAAItB,EAAQ,GAAG7B,OAAQmD,IAEnC,GAAIrB,KAAKiC,gBAAgB1B,EAAOa,EAAGC,EAAGtB,GAAU,CAC5C,IAAImC,EAAalC,KAAKC,cAAczC,aAAauC,GAIjD,GAFAC,KAAKmC,WAAW5B,EAAOa,EAAGC,EAAGa,EAAYJ,IAEpC9B,KAAKoC,iBAAiBF,GAAa,CACpC,IAAIG,EAAerC,KAAKC,cAAczC,aAAa8C,GACnD+B,EAAaC,QAEb,IAAIC,EAASvC,KAAK6B,QAAQK,EAAYG,EAAcP,EAAQ,EAAGL,GAE/D,GAAIc,EAAQ,OAAOA,CAEvB,CACJ,CAGZ,CAEA,OAAO,IACX,CAEAJ,UAAAA,CAAW5B,EAAOa,EAAGC,EAAGtB,GAAkB,IAATyC,EAAEjB,UAAArD,OAAA,QAAAsD,IAAAD,UAAA,GAAAA,UAAA,GAAG,EAClC,IAAK,IAAIkB,EAAK,EAAGA,EAAKlC,EAAMrC,OAAQuE,IAChC,IAAK,IAAIC,EAAK,EAAGA,EAAKnC,EAAM,GAAGrC,OAAQwE,IAC/BnC,EAAMkC,GAAIC,IAAkC,GAA3B3C,EAAQqB,EAAIqB,GAAIpB,EAAIqB,KACrC3C,EAAQqB,EAAIqB,GAAIpB,EAAIqB,GAAMF,EAI1C,CAEAP,eAAAA,CAAgB1B,EAAOa,EAAGC,EAAGtB,GACzB,GAAIqB,EAAIb,EAAMrC,QAAU6B,EAAQ7B,QAAUmD,EAAId,EAAM,GAAGrC,QAAU6B,EAAQ,GAAG7B,OAAQ,OAAO,EAE3F,IAAK,IAAIuE,EAAK,EAAGA,EAAKlC,EAAMrC,OAAQuE,IAChC,IAAK,IAAIC,EAAK,EAAGA,EAAKnC,EAAM,GAAGrC,OAAQwE,IACnC,GAAInC,EAAMkC,GAAIC,IAAkC,GAA3B3C,EAAQqB,EAAIqB,GAAIpB,EAAIqB,GAAU,OAAO,EAIlE,OAAO,CACX,CAEAN,gBAAAA,CAAiBrC,GAKb,IAAI4C,EAAiB3C,KAAKC,cAAczC,aAAauC,GAEjD6C,EAAQ,EAEZ,OAAa,CAGT,GAFAA,EAAQ5C,KAAK6C,+BAA+BF,IAE9B,GAAVC,EAAa,OAAO,EACnB,GAAIA,EAAQ,GAAK,EAAG,OAAO,CACpC,CAEJ,CAEAC,8BAAAA,CAA+B9C,GAC3B,IAAI+C,EAAc9C,KAAK+C,4BAA4BhD,GACnD,IAAK+C,EAAa,OAAQ,EAE1B,IAAIE,EAAU,CAAEC,IAAK,GAKrB,OAHAlD,EAAQ+C,EAAY1B,GAAG0B,EAAYzB,IAAM,EACzCrB,KAAKkD,gBAAgBnD,EAAS+C,EAAaE,GAEpCA,EAAQC,GACnB,CAEAF,2BAAAA,CAA4BhD,GACxB,IAAK,IAAIqB,EAAI,EAAGA,EAAIrB,EAAQ7B,OAAQkD,IAChC,IAAK,IAAIC,EAAI,EAAGA,EAAItB,EAAQ,GAAG7B,OAAQmD,IACnC,GAAqB,GAAjBtB,EAAQqB,GAAGC,GAAS,MAAO,CAAED,EAAGA,EAAGC,EAAGA,GAIlD,OAAO,IACX,CAEA6B,eAAAA,CAAgBnD,EAASoD,EAAOH,GAE5B,IAAII,EAAuBpD,KAAKqD,uBAAuBtD,EAASoD,GAGhEC,EAAqBzC,SAAQ2C,IACzBN,EAAQC,MACRlD,EAAQuD,EAAUlC,GAAGkC,EAAUjC,IAAM,CAAC,IAG1C+B,EAAqBzC,SAAQ2C,IACzBtD,KAAKkD,gBAAgBnD,EAASuD,EAAWN,EAAQ,GAEzD,CAEAK,sBAAAA,CAAuBtD,EAASoD,GAC5B,IAOII,EAAkB,GAWtB,MAlBiB,CACb,CAAC,GAAI,GACL,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,CAAC,EAAG,IAKG5C,SAAQ6C,IACfA,EAAE,IAAML,EAAM/B,EACdoC,EAAE,IAAML,EAAM9B,EAEVmC,EAAE,IAAM,GAAKA,EAAE,GAAKzD,EAAQ7B,QAAUsF,EAAE,IAAM,GAAKA,EAAE,GAAKzD,EAAQ,GAAG7B,QAC1C,GAAvB6B,EAAQyD,EAAE,IAAIA,EAAE,KAAUD,EAAgB5E,KAAK,CAAEyC,EAAGoC,EAAE,GAAInC,EAAGmC,EAAE,IACvE,IAGGD,CACX,EC7NJE,UAAaC,IACX,MAAM,QAAE3D,EAAO,UAAEO,GAAcoD,EAAMC,KAYxB,IAAI9D,EAAOE,GAEJuB,MAAMhB,EAAWP,GANrBA,IACd6D,YAAY,CAACrB,OAAQxC,GAAS,GAKuB,C","sources":["shared/services/shared-service.js","tangram/solver/Solver.js","tangram/solver/solver.worker.js"],"sourcesContent":["export class SharedService {\r\n  cloneNDArray(originalArray) {\r\n    function cloneArray(array) {\r\n      return Array.isArray(array) ? array.map(cloneArray) : array;\r\n    }\r\n\r\n    return cloneArray(originalArray);\r\n  }\r\n\r\n  areArraysEqual(arr1, arr2) {\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      if (arr1[i].length !== arr2[i].length) {\r\n        return false;\r\n      }\r\n\r\n      for (let j = 0; j < arr1[i].length; j++) {\r\n        if (arr1[i][j] !== arr2[i][j]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  rotate2DArray(matrix) {\r\n    const rows = matrix.length;\r\n    const cols = matrix[0].length;\r\n\r\n    // Transpose the matrix\r\n    const transposedMatrix = [];\r\n    for (let j = 0; j < cols; j++) {\r\n      const newRow = [];\r\n      for (let i = 0; i < rows; i++) {\r\n        newRow.push(matrix[i][j]);\r\n      }\r\n      transposedMatrix.push(newRow);\r\n    }\r\n\r\n    // Reverse the rows to get the final rotated matrix\r\n    const rotatedMatrix = [];\r\n    for (let i = 0; i < cols; i++) {\r\n      const reversedRow = transposedMatrix[i].reverse();\r\n      rotatedMatrix.push(reversedRow);\r\n    }\r\n\r\n    return rotatedMatrix;\r\n  }\r\n\r\n  reverse2DArray(matrix) {\r\n    const numRows = matrix.length;\r\n    const numCols = matrix[0].length;\r\n\r\n    const reversedMatrix = [];\r\n\r\n    for (let i = 0; i < numRows; i++) {\r\n      const reversedRow = [];\r\n      for (let j = numCols - 1; j >= 0; j--) {\r\n        reversedRow.push(matrix[i][j]);\r\n      }\r\n      reversedMatrix.push(reversedRow);\r\n    }\r\n\r\n    return reversedMatrix;\r\n  }\r\n\r\n  cropMatrix(matrix) {\r\n    let minX = matrix[0].length;\r\n    let maxX = 0;\r\n    let minY = matrix.length;\r\n    let maxY = 0;\r\n\r\n    // Find the bounds of the non-zero values\r\n    for (let i = 0; i < matrix.length; i++) {\r\n      for (let j = 0; j < matrix[i].length; j++) {\r\n        if (matrix[i][j] !== false) {\r\n          minX = Math.min(minX, j);\r\n          maxX = Math.max(maxX, j);\r\n          minY = Math.min(minY, i);\r\n          maxY = Math.max(maxY, i);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create the cropped matrix\r\n    let croppedMatrix = [];\r\n    for (let i = minY; i <= maxY; i++) {\r\n      let row = [];\r\n      for (let j = minX; j <= maxX; j++) {\r\n        row.push(matrix[i][j]);\r\n      }\r\n      croppedMatrix.push(row);\r\n    }\r\n    return croppedMatrix;\r\n  }\r\n}","import { SharedService } from \"../../shared/services/shared-service\";\r\n\r\nexport class Solver {\r\n    constructor(pattern) {\r\n        this.sharedService = new SharedService();\r\n\r\n        this.initialPattern = pattern;\r\n\r\n        this.nbIteration = 0;\r\n    }\r\n\r\n    getAllPiecesCombinations(pieceObjList) {       \r\n        let pieceList = pieceObjList.map((piece) => this.sharedService.cropMatrix(piece[\"data\"]));\r\n\r\n        console.log(pieceList);\r\n\r\n        let finalPieceList = [];\r\n\r\n        pieceList.forEach(piece => {\r\n            let pieceCombinations = [];\r\n\r\n            pieceCombinations.push(piece);\r\n            pieceCombinations.push(this.sharedService.reverse2DArray(piece));\r\n\r\n\r\n            let rotatedPiece = this.sharedService.cloneNDArray(piece);\r\n\r\n            for (let i = 0; i < 3; i++) {\r\n                rotatedPiece = this.sharedService.rotate2DArray(rotatedPiece);\r\n                pieceCombinations.push(rotatedPiece);\r\n                pieceCombinations.push(this.sharedService.reverse2DArray(rotatedPiece));\r\n            }\r\n\r\n            finalPieceList.push(this.removeDuplicateArrays(pieceCombinations));\r\n        });\r\n\r\n        return finalPieceList;\r\n    }\r\n\r\n    removeDuplicateArrays(arrays) {\r\n        const uniqueArrays = [];\r\n\r\n        for (const array of arrays) {\r\n            let isDuplicate = false;\r\n            for (const uniqueArray of uniqueArrays) {\r\n                if (this.sharedService.areArraysEqual(array, uniqueArray)) {\r\n                    isDuplicate = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isDuplicate) {\r\n                uniqueArrays.push(array);\r\n            }\r\n        }\r\n\r\n        return uniqueArrays;\r\n    }\r\n\r\n    parsePattern(pattern){\r\n        // Piece to available\r\n\r\n        for (let x = 0; x < pattern.length; x++) {\r\n            for (let y = 0; y < pattern[0].length; y++) {\r\n                if(pattern[x][y] != -1) pattern[x][y] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    solve(pieceList, pattern=null, callback=null) {\r\n        this.nbIteration = 0;\r\n\r\n        // console.log(pattern);\r\n        let allPieces = this.getAllPiecesCombinations(pieceList);\r\n        allPieces = allPieces.sort(() => (Math.random() > .5) ? 1 : -1);\r\n\r\n        // console.log(allPieces);\r\n\r\n        if(!pattern) pattern = this.sharedService.cloneNDArray(this.initialPattern);\r\n        else this.parsePattern(pattern);\r\n\r\n        pattern = this.process(pattern, allPieces, 1, callback);\r\n\r\n        return pattern;\r\n    }\r\n\r\n    process(pattern, pieceList, level, callback) {\r\n        this.nbIteration++;\r\n\r\n        if(callback){\r\n            if(pieceList.length == 0){\r\n                setTimeout(() => {\r\n                    callback(pattern);\r\n                }, 250);\r\n            }\r\n            else if(this.nbIteration % 100 == 0) callback(pattern);\r\n        }\r\n        if (pieceList.length == 0) return pattern; // No pieces to place = win !\r\n\r\n        const pieceTransformations = pieceList[0];\r\n\r\n        for (let j = 0; j < pieceTransformations.length; j++) {\r\n            const piece = pieceTransformations[j];\r\n\r\n            for (let x = 0; x < pattern.length; x++) {\r\n                for (let y = 0; y < pattern[0].length; y++) {\r\n\r\n                    if (this.isPiecePlacable(piece, x, y, pattern)) {\r\n                        let newPattern = this.sharedService.cloneNDArray(pattern);\r\n                        \r\n                        this.placePiece(piece, x, y, newPattern, level);  // Place pieces\r\n                        // console.log(newPattern);\r\n                        if (!this.isWrongAreaExist(newPattern)) {    // Prunning !\r\n                            let newPieceList = this.sharedService.cloneNDArray(pieceList);\r\n                            newPieceList.shift();\r\n                            // console.log(\"newPieceList\");\r\n                            let result = this.process(newPattern, newPieceList, level + 1, callback);\r\n\r\n                            if (result) return result;       // Return result = win !!\r\n                            // Else nothing so piece will be moved\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;    // Piece not working = set up impossible\r\n    }\r\n\r\n    placePiece(piece, x, y, pattern, id = 1) {\r\n        for (let px = 0; px < piece.length; px++) {\r\n            for (let py = 0; py < piece[0].length; py++) {\r\n                if (piece[px][py] && pattern[x + px][y + py] == 0) {\r\n                    pattern[x + px][y + py] = id;\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    isPiecePlacable(piece, x, y, pattern) {\r\n        if (x + piece.length >= pattern.length || y + piece[0].length >= pattern[0].length) return false;\r\n\r\n        for (let px = 0; px < piece.length; px++) {\r\n            for (let py = 0; py < piece[0].length; py++) {\r\n                if (piece[px][py] && pattern[x + px][y + py] != 0) return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    isWrongAreaExist(pattern) {\r\n        // Pattern definition\r\n        // -1 : not available\r\n        // 0 : available\r\n        // other : block\r\n        let patternToCount = this.sharedService.cloneNDArray(pattern);\r\n\r\n        let value = 0;  // Nb of unit by area\r\n\r\n        while (true) {\r\n            value = this.countBlocksInNextAreaAvailable(patternToCount);\r\n\r\n            if (value == -1) return false;\r\n            else if (value % 5 != 0) return true;\r\n        }\r\n\r\n    }\r\n\r\n    countBlocksInNextAreaAvailable(pattern) {\r\n        let originCoord = this.getFirstBlockCoordAvailable(pattern);\r\n        if (!originCoord) return -1; // No blocks available\r\n\r\n        let counter = { val: 1 }; // Use an object for ref parameters exchange\r\n\r\n        pattern[originCoord.x][originCoord.y] = -1;\r\n        this.countAreaBlocks(pattern, originCoord, counter);\r\n\r\n        return counter.val;\r\n    }\r\n\r\n    getFirstBlockCoordAvailable(pattern) {\r\n        for (let x = 0; x < pattern.length; x++) {\r\n            for (let y = 0; y < pattern[0].length; y++) {\r\n                if (pattern[x][y] == 0) return { x: x, y: y };\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    countAreaBlocks(pattern, coord, counter) {\r\n        // recursive function that count all the blocks in an area\r\n        let blockCoordsAvailable = this.getNeighboorsAvailable(pattern, coord);\r\n        // console.log(blockCoordsAvailable);\r\n\r\n        blockCoordsAvailable.forEach(blocCoord => {\r\n            counter.val++;\r\n            pattern[blocCoord.x][blocCoord.y] = -1; // To avoid duplicate count\r\n        });\r\n\r\n        blockCoordsAvailable.forEach(blocCoord => {\r\n            this.countAreaBlocks(pattern, blocCoord, counter);\r\n        });\r\n    }\r\n\r\n    getNeighboorsAvailable(pattern, coord) {\r\n        let directions = [\r\n            [0, -1],\r\n            [-1, 0],\r\n            [1, 0],\r\n            [0, 1],\r\n        ]\r\n\r\n        let coordsAvailable = [];\r\n\r\n        directions.forEach(d => {\r\n            d[0] += coord.x;\r\n            d[1] += coord.y;\r\n\r\n            if (d[0] >= 0 && d[0] < pattern.length && d[1] >= 0 && d[1] < pattern[0].length) {\r\n                if (pattern[d[0]][d[1]] == 0) coordsAvailable.push({ x: d[0], y: d[1] })\r\n            }\r\n        });\r\n\r\n        return coordsAvailable;\r\n    }\r\n}","// Worker\r\n\r\nimport { Solver } from \"./Solver\";\r\n\r\nonmessage = (event) => {\r\n  const { pattern, pieceList } = event.data;\r\n\r\n  // console.log(\"PATTERN\");\r\n  // console.log(pattern);\r\n\r\n  // console.log(\"PIECE LIST\");\r\n  // console.log(pieceList);\r\n\r\n  let callback = (pattern) => {\r\n    postMessage({result: pattern});\r\n  };\r\n\r\n  let solver = new Solver(pattern);\r\n\r\n  let result = solver.solve(pieceList, pattern, callback);\r\n\r\n  // setTimeout(() => {\r\n  //   postMessage({result: result});\r\n  // }, 500);\r\n};"],"names":["SharedService","cloneNDArray","originalArray","cloneArray","array","Array","isArray","map","areArraysEqual","arr1","arr2","length","i","j","rotate2DArray","matrix","rows","cols","transposedMatrix","newRow","push","rotatedMatrix","reversedRow","reverse","reverse2DArray","numRows","numCols","reversedMatrix","cropMatrix","minX","maxX","minY","maxY","Math","min","max","croppedMatrix","row","Solver","constructor","pattern","this","sharedService","initialPattern","nbIteration","getAllPiecesCombinations","pieceObjList","pieceList","piece","console","log","finalPieceList","forEach","pieceCombinations","rotatedPiece","removeDuplicateArrays","arrays","uniqueArrays","isDuplicate","uniqueArray","parsePattern","x","y","solve","arguments","undefined","callback","allPieces","sort","random","process","level","setTimeout","pieceTransformations","isPiecePlacable","newPattern","placePiece","isWrongAreaExist","newPieceList","shift","result","id","px","py","patternToCount","value","countBlocksInNextAreaAvailable","originCoord","getFirstBlockCoordAvailable","counter","val","countAreaBlocks","coord","blockCoordsAvailable","getNeighboorsAvailable","blocCoord","coordsAvailable","d","onmessage","event","data","postMessage"],"sourceRoot":""}