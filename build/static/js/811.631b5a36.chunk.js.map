{"version":3,"file":"static/js/811.631b5a36.chunk.js","mappings":"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","sources":["shared/services/shared-service.js","tangram/solver/Solver.js","tangram/solver/solver.worker.js"],"sourcesContent":["export class SharedService {\r\n  cloneNDArray(originalArray) {\r\n    function cloneArray(array) {\r\n      return Array.isArray(array) ? array.map(cloneArray) : array;\r\n    }\r\n\r\n    return cloneArray(originalArray);\r\n  }\r\n\r\n  areArraysEqual(arr1, arr2) {\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      if (arr1[i].length !== arr2[i].length) {\r\n        return false;\r\n      }\r\n\r\n      for (let j = 0; j < arr1[i].length; j++) {\r\n        if (arr1[i][j] !== arr2[i][j]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  rotate2DArray(matrix) {\r\n    const rows = matrix.length;\r\n    const cols = matrix[0].length;\r\n\r\n    // Transpose the matrix\r\n    const transposedMatrix = [];\r\n    for (let j = 0; j < cols; j++) {\r\n      const newRow = [];\r\n      for (let i = 0; i < rows; i++) {\r\n        newRow.push(matrix[i][j]);\r\n      }\r\n      transposedMatrix.push(newRow);\r\n    }\r\n\r\n    // Reverse the rows to get the final rotated matrix\r\n    const rotatedMatrix = [];\r\n    for (let i = 0; i < cols; i++) {\r\n      const reversedRow = transposedMatrix[i].reverse();\r\n      rotatedMatrix.push(reversedRow);\r\n    }\r\n\r\n    return rotatedMatrix;\r\n  }\r\n\r\n  reverse2DArray(matrix) {\r\n    const numRows = matrix.length;\r\n    const numCols = matrix[0].length;\r\n\r\n    const reversedMatrix = [];\r\n\r\n    for (let i = 0; i < numRows; i++) {\r\n      const reversedRow = [];\r\n      for (let j = numCols - 1; j >= 0; j--) {\r\n        reversedRow.push(matrix[i][j]);\r\n      }\r\n      reversedMatrix.push(reversedRow);\r\n    }\r\n\r\n    return reversedMatrix;\r\n  }\r\n\r\n  cropMatrix(matrix) {\r\n    let minX = matrix[0].length;\r\n    let maxX = 0;\r\n    let minY = matrix.length;\r\n    let maxY = 0;\r\n\r\n    // Find the bounds of the non-zero values\r\n    for (let i = 0; i < matrix.length; i++) {\r\n      for (let j = 0; j < matrix[i].length; j++) {\r\n        if (matrix[i][j] !== false) {\r\n          minX = Math.min(minX, j);\r\n          maxX = Math.max(maxX, j);\r\n          minY = Math.min(minY, i);\r\n          maxY = Math.max(maxY, i);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create the cropped matrix\r\n    let croppedMatrix = [];\r\n    for (let i = minY; i <= maxY; i++) {\r\n      let row = [];\r\n      for (let j = minX; j <= maxX; j++) {\r\n        row.push(matrix[i][j]);\r\n      }\r\n      croppedMatrix.push(row);\r\n    }\r\n    return croppedMatrix;\r\n  }\r\n\r\n  getCropAreas(patternToCrop) {\r\n    // Pattern definition\r\n    // 0 : available\r\n    // other : block or none\r\n    patternToCrop = this.cloneNDArray(patternToCrop);\r\n\r\n    let cropAreas = [];\r\n\r\n    let id = 100; // Use to separate area\r\n\r\n    while (true) {\r\n      let result = this.countBlocksInNextAreaAvailable(patternToCrop, id);\r\n\r\n      if (!result) break;\r\n\r\n      let {\r\n        count,\r\n        pattern\r\n      } = result;\r\n\r\n      let newCropArea = this.cropMatrixByValue(pattern, id);\r\n\r\n      cropAreas.push({area: newCropArea, count: count});\r\n\r\n      id += 100;\r\n    }\r\n\r\n    return cropAreas;\r\n  }\r\n\r\n  countBlocksInNextAreaAvailable(pattern, id) {\r\n    let originCoord = this.getFirstBlockCoordAvailable(pattern);\r\n    if (!originCoord) return null; // No blocks available\r\n\r\n    let counter = {\r\n      val: 1,\r\n      currentId: id\r\n    }; // Use an object for ref parameters exchange\r\n\r\n    pattern[originCoord.x][originCoord.y] = id;\r\n    this.countAreaBlocks(pattern, originCoord, counter);\r\n\r\n    return {\r\n      count: counter.val,\r\n      pattern: pattern\r\n    };\r\n  }\r\n\r\n  getFirstBlockCoordAvailable(pattern) {\r\n    for (let x = 0; x < pattern.length; x++) {\r\n      for (let y = 0; y < pattern[0].length; y++) {\r\n        if (pattern[x][y] == 0) return {\r\n          x: x,\r\n          y: y\r\n        };\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  countAreaBlocks(pattern, coord, counter) {\r\n    // recursive function that count all the blocks in an area\r\n    let blockCoordsAvailable = this.getNeighboorsAvailable(pattern, coord);\r\n\r\n    blockCoordsAvailable.forEach(blocCoord => {\r\n      counter.val++;\r\n      pattern[blocCoord.x][blocCoord.y] = counter.currentId; // To avoid duplicate count\r\n    });\r\n\r\n    blockCoordsAvailable.forEach(blocCoord => {\r\n      this.countAreaBlocks(pattern, blocCoord, counter);\r\n    });\r\n  }\r\n\r\n  getNeighboorsAvailable(pattern, coord) {\r\n    let directions = [\r\n      [0, -1],\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, 1],\r\n    ]\r\n\r\n    let coordsAvailable = [];\r\n\r\n    directions.forEach(d => {\r\n      d[0] += coord.x;\r\n      d[1] += coord.y;\r\n\r\n      if (d[0] >= 0 && d[0] < pattern.length && d[1] >= 0 && d[1] < pattern[0].length) {\r\n        if (pattern[d[0]][d[1]] == 0) coordsAvailable.push({\r\n          x: d[0],\r\n          y: d[1]\r\n        })\r\n      }\r\n    });\r\n\r\n    return coordsAvailable;\r\n  }\r\n\r\n  cropMatrixByValue(matrix, valueToKeep) {\r\n    let minX = matrix[0].length;\r\n    let maxX = 0;\r\n    let minY = matrix.length;\r\n    let maxY = 0;\r\n\r\n    // Find the bounds of the non-zero values\r\n    for (let i = 0; i < matrix.length; i++) {\r\n      for (let j = 0; j < matrix[i].length; j++) {\r\n        if (matrix[i][j] == valueToKeep) {\r\n          minX = Math.min(minX, j);\r\n          maxX = Math.max(maxX, j);\r\n          minY = Math.min(minY, i);\r\n          maxY = Math.max(maxY, i);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create the cropped matrix\r\n    let croppedMatrix = [];\r\n    for (let i = minY; i <= maxY; i++) {\r\n      let row = [];\r\n      for (let j = minX; j <= maxX; j++) {\r\n        row.push(matrix[i][j]);\r\n      }\r\n      croppedMatrix.push(row);\r\n    }\r\n    return croppedMatrix;\r\n  }\r\n\r\n  replaceValueIn2Darray(matrix, oldValue, newValue) {\r\n    for (let i = 0; i < matrix.length; i++) {\r\n      for (let j = 0; j < matrix[i].length; j++) {\r\n        if (matrix[i][j] == oldValue) matrix[i][j] = newValue;\r\n      }\r\n    }\r\n  }\r\n}","import { SharedService } from \"../../shared/services/shared-service\";\r\n\r\nexport class Solver {\r\n    constructor(pattern) {\r\n        this.sharedService = new SharedService();\r\n\r\n        this.initialPattern = pattern;\r\n\r\n        this.nbIteration = 0;\r\n    }\r\n\r\n    getAllPiecesCombinations(pieceObjList) {       \r\n        let pieceList = pieceObjList.map((piece) => this.sharedService.cropMatrix(piece[\"data\"]));\r\n\r\n        // console.log(pieceList);\r\n\r\n        let finalPieceList = [];\r\n\r\n        pieceList.forEach(piece => {\r\n            let pieceCombinations = [];\r\n\r\n            pieceCombinations.push(piece);\r\n            pieceCombinations.push(this.sharedService.reverse2DArray(piece));\r\n\r\n\r\n            let rotatedPiece = this.sharedService.cloneNDArray(piece);\r\n\r\n            for (let i = 0; i < 3; i++) {\r\n                rotatedPiece = this.sharedService.rotate2DArray(rotatedPiece);\r\n                pieceCombinations.push(rotatedPiece);\r\n                pieceCombinations.push(this.sharedService.reverse2DArray(rotatedPiece));\r\n            }\r\n\r\n            finalPieceList.push(this.removeDuplicateArrays(pieceCombinations));\r\n        });\r\n\r\n        return finalPieceList;\r\n    }\r\n\r\n    removeDuplicateArrays(arrays) {\r\n        const uniqueArrays = [];\r\n\r\n        for (const array of arrays) {\r\n            let isDuplicate = false;\r\n            for (const uniqueArray of uniqueArrays) {\r\n                if (this.sharedService.areArraysEqual(array, uniqueArray)) {\r\n                    isDuplicate = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isDuplicate) {\r\n                uniqueArrays.push(array);\r\n            }\r\n        }\r\n\r\n        return uniqueArrays;\r\n    }\r\n\r\n    parsePattern(pattern){\r\n        // Piece to available\r\n\r\n        for (let x = 0; x < pattern.length; x++) {\r\n            for (let y = 0; y < pattern[0].length; y++) {\r\n                if(pattern[x][y] != -1) pattern[x][y] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    solve(pieceList, pattern=null, callback=null) {\r\n        this.nbIteration = 0;\r\n\r\n        // console.log(pattern);\r\n        let allPieces = this.getAllPiecesCombinations(pieceList);\r\n        allPieces = allPieces.sort(() => (Math.random() > .5) ? 1 : -1);\r\n\r\n        if(!pattern) pattern = this.sharedService.cloneNDArray(this.initialPattern);\r\n        else this.parsePattern(pattern);\r\n\r\n        pattern = this.process(pattern, allPieces, 1, callback);\r\n\r\n        return pattern;\r\n    }\r\n\r\n    process(pattern, pieceList, level, callback) {\r\n        this.nbIteration++;\r\n\r\n        if(callback){\r\n            if(pieceList.length == 0){\r\n                callback(pattern, true);\r\n            }\r\n            else if(this.nbIteration % 100 == 0) callback(pattern);\r\n        }\r\n        if (pieceList.length == 0) return pattern; // No pieces to place = win !\r\n\r\n        const pieceTransformations = pieceList[0];\r\n\r\n        for (let j = 0; j < pieceTransformations.length; j++) {\r\n            const piece = pieceTransformations[j];\r\n\r\n            for (let x = 0; x < pattern.length; x++) {\r\n                for (let y = 0; y < pattern[0].length; y++) {\r\n\r\n                    if (this.isPiecePlacable(piece, x, y, pattern)) {\r\n                        let newPattern = this.sharedService.cloneNDArray(pattern);\r\n                        \r\n                        this.placePiece(piece, x, y, newPattern, level);  // Place pieces\r\n                        // console.log(newPattern);\r\n                        let newPieceList = this.sharedService.cloneNDArray(pieceList);\r\n                        newPieceList.shift();\r\n\r\n                        if (!this.isWrongAreaExist(newPattern, newPieceList)) {    // Prunning !\r\n                            // console.log(\"newPieceList\");\r\n                            let result = this.process(newPattern, newPieceList, level + 1, callback);\r\n\r\n                            if (result) return result;       // Return result = win !!\r\n                            // Else nothing so piece will be moved\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;    // Piece not working = set up impossible\r\n    }\r\n\r\n    placePiece(piece, x, y, pattern, id = 1) {\r\n        for (let px = 0; px < piece.length; px++) {\r\n            for (let py = 0; py < piece[0].length; py++) {\r\n                if (piece[px][py] && pattern[x + px][y + py] == 0) {\r\n                    pattern[x + px][y + py] = id;\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    isPiecePlacable(piece, x, y, pattern) {\r\n        if (x + piece.length >= pattern.length || y + piece[0].length >= pattern[0].length) return false;\r\n\r\n        for (let px = 0; px < piece.length; px++) {\r\n            for (let py = 0; py < piece[0].length; py++) {\r\n                if (piece[px][py] && pattern[x + px][y + py] != 0) return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    isWrongAreaExist(pattern, pieceList) {\r\n        // Pattern definition\r\n        // -1 : not available\r\n        // 0 : available\r\n        // other : block\r\n\r\n        let cropAreas = this.sharedService.getCropAreas(pattern);\r\n\r\n        for (let i = 0; i < cropAreas.length; i++) {\r\n            const cropArea = cropAreas[i];\r\n            \r\n            if(cropArea.count %5 != 0) return true; \r\n            else if(cropArea.count == 5){\r\n                // console.log(\"piece remaining\");\r\n                // console.log(pieceList);\r\n\r\n                let patternWorks = false;\r\n                for (let j = 0; j < pieceList.length; j++) {\r\n                    const pieceTransformations = pieceList[j];\r\n                    \r\n                    for (let k = 0; k < pieceTransformations.length; k++) {\r\n                        const piece = pieceTransformations[k];\r\n                        \r\n                        if(cropArea.area.length == piece.length && cropArea.area[0].length == piece[0].length) {\r\n                            let pieceWorks = true;\r\n                            for(let x = 0; x < piece.length; x++){\r\n                                for(let y = 0; y < piece[0].length; y++){\r\n                                    if(cropArea.area[x][y] >= 100 && !piece[x][y]){ // Block value must be greater or equal than 100\r\n                                        pieceWorks = false;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(pieceWorks){\r\n                                patternWorks = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if(patternWorks) break;\r\n                }\r\n                if(!patternWorks) return true;\r\n            }\r\n        }\r\n        // RETIRER LA PIECE QUAND UNE HYPOTHESE SE VERIFIE DANS LE CAS OU 2 AREAS SONT IDENTIQUES\r\n\r\n        return false;\r\n    }\r\n}","// Worker\r\n\r\nimport { Solver } from \"./Solver\";\r\n\r\nonmessage = (event) => {\r\n  const { pattern, pieceList } = event.data;\r\n\r\n  // console.log(\"PATTERN\");\r\n  // console.log(pattern);\r\n\r\n  // console.log(\"PIECE LIST\");\r\n  // console.log(pieceList);\r\n\r\n  let callback = (pattern, status=false) => {\r\n    postMessage({result: pattern, status: status});\r\n  };\r\n\r\n  let solver = new Solver(pattern);\r\n\r\n  let result = solver.solve(pieceList, pattern, callback);\r\n\r\n  if(!result) postMessage({result: null, status: true});\r\n\r\n  // setTimeout(() => {\r\n  //   postMessage({result: result});\r\n  // }, 500);\r\n};"],"names":["SharedService","cloneNDArray","originalArray","cloneArray","array","Array","isArray","map","areArraysEqual","arr1","arr2","length","i","j","rotate2DArray","matrix","rows","cols","transposedMatrix","newRow","push","rotatedMatrix","reversedRow","reverse","reverse2DArray","numRows","numCols","reversedMatrix","cropMatrix","minX","maxX","minY","maxY","Math","min","max","croppedMatrix","row","getCropAreas","patternToCrop","this","cropAreas","id","result","countBlocksInNextAreaAvailable","count","pattern","newCropArea","cropMatrixByValue","area","originCoord","getFirstBlockCoordAvailable","counter","val","currentId","x","y","countAreaBlocks","coord","blockCoordsAvailable","getNeighboorsAvailable","forEach","blocCoord","coordsAvailable","d","valueToKeep","replaceValueIn2Darray","oldValue","newValue","Solver","constructor","sharedService","initialPattern","nbIteration","getAllPiecesCombinations","pieceObjList","pieceList","piece","finalPieceList","pieceCombinations","rotatedPiece","removeDuplicateArrays","arrays","uniqueArrays","isDuplicate","uniqueArray","parsePattern","solve","arguments","undefined","callback","allPieces","sort","random","process","level","pieceTransformations","isPiecePlacable","newPattern","placePiece","newPieceList","shift","isWrongAreaExist","px","py","cropArea","patternWorks","k","pieceWorks","onmessage","event","data","postMessage","status"],"sourceRoot":""}