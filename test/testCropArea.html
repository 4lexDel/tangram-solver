<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        let patternToCrop = [
            [-1, 0, -1, -1, -1, -1, -1, 0, 0],
            [0, 0, -1, -1, 0, 0, 0, -1, 0],
            [-1, 0, -1, -1, 0, -1, 0, -1, 0],
            [-1, 0, -1, -1, -1, -1, -1, -1, 0],
            [-1, -1, 0, -1, 0, 0, 0, 0, 0],
        ]
        console.log("patternToCrop");
        console.log(patternToCrop);

        let cropAreas = getCropAreas(patternToCrop);

        console.log("CROP AREAS");
        console.log(cropAreas);

        console.log(patternToCrop);

        function getCropAreas(patternToCrop) {
            // Pattern definition
            // 0 : available
            // other : block or none

            patternToCrop = cloneNDArray(patternToCrop);

            let cropAreas = [];

            let value = 0; // Nb of unit by area
            let id = 100; // Use to separate area

            while (true) {
                let result = countBlocksInNextAreaAvailable(patternToCrop, id);

                if (!result) break;

                let {
                    count,
                    pattern
                } = result;

                let newCropArea = cropMatrixByValue(pattern, id);

                cropAreas.push(newCropArea);

                id += 100;
            }

            return cropAreas;
        }

        function cloneNDArray(originalArray) {
            function cloneArray(array) {
                return Array.isArray(array) ? array.map(cloneArray) : array;
            }

            return cloneArray(originalArray);
        }

        function countBlocksInNextAreaAvailable(pattern, id) {
            let originCoord = getFirstBlockCoordAvailable(pattern);
            if (!originCoord) return null; // No blocks available

            let counter = {
                val: 1,
                currentId: id
            }; // Use an object for ref parameters exchange

            pattern[originCoord.x][originCoord.y] = id;
            countAreaBlocks(pattern, originCoord, counter);

            return {
                count: counter.val,
                pattern: pattern
            };
        }

        function getFirstBlockCoordAvailable(pattern) {
            for (let x = 0; x < pattern.length; x++) {
                for (let y = 0; y < pattern[0].length; y++) {
                    if (pattern[x][y] == 0) return {
                        x: x,
                        y: y
                    };
                }
            }

            return null;
        }

        function countAreaBlocks(pattern, coord, counter) {
            // recursive function that count all the blocks in an area
            let blockCoordsAvailable = getNeighboorsAvailable(pattern, coord);

            blockCoordsAvailable.forEach(blocCoord => {
                counter.val++;
                pattern[blocCoord.x][blocCoord.y] = counter.currentId; // To avoid duplicate count
            });

            blockCoordsAvailable.forEach(blocCoord => {
                countAreaBlocks(pattern, blocCoord, counter);
            });
        }

        function getNeighboorsAvailable(pattern, coord) {
            let directions = [
                [0, -1],
                [-1, 0],
                [1, 0],
                [0, 1],
            ]

            let coordsAvailable = [];

            directions.forEach(d => {
                d[0] += coord.x;
                d[1] += coord.y;

                if (d[0] >= 0 && d[0] < pattern.length && d[1] >= 0 && d[1] < pattern[0].length) {
                    if (pattern[d[0]][d[1]] == 0) coordsAvailable.push({
                        x: d[0],
                        y: d[1]
                    })
                }
            });

            return coordsAvailable;
        }

        function cropMatrixByValue(matrix, valueToKeep) {
            let minX = matrix[0].length;
            let maxX = 0;
            let minY = matrix.length;
            let maxY = 0;

            // Find the bounds of the non-zero values
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] == valueToKeep) {
                        minX = Math.min(minX, j);
                        maxX = Math.max(maxX, j);
                        minY = Math.min(minY, i);
                        maxY = Math.max(maxY, i);
                    }
                }
            }

            // Create the cropped matrix
            let croppedMatrix = [];
            for (let i = minY; i <= maxY; i++) {
                let row = [];
                for (let j = minX; j <= maxX; j++) {
                    row.push(matrix[i][j]);
                }
                croppedMatrix.push(row);
            }
            return croppedMatrix;
        }

        function replaceValueIn2Darray(matrix, oldValue, newValue) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] == oldValue) matrix[i][j] = newValue;
                }
            }
        }
    </script>
</body>

</html>